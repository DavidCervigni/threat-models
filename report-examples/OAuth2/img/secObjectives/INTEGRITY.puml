







@startuml
digraph G {
rankdir="RL";
  node [shape=plaintext, fontname="Arial" fontsize="12"];
    
"INTEGRITY" [fillcolor="#bae9ff", style=filled shape=ellipse, color="#2bbcff", label="INTEGRITY", label= 
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="center"><b>INTEGRITY</b><br/>

Ability to maintain fundamental integrity of the system
</td></tr>
   </table>>]

               "Client_Secrets_disclosure" [ fillcolor="#F8CECC", style=filled, shape=polygon, color="#B85450"
    label= 
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="center"><b>Client_Secrets_disclosure ATTACK</b> <br/></td></tr>
     <tr><td align="center">

Obtain Secret From Source Code or Binary: This applies for all client types.<br/>For open source projects, secrets can be extracted directly from source code in<br/>their public repositories.  Secrets can be extracted from application binaries<br/>just as easily when the published source is not available to the attack[...]
</td></tr>
   </table>>
   ];
    

    "Client_Secrets_disclosure_countermeasure0" [ 
       fillcolor="#D5E8D4", style=filled, shape=polygon, color="#82B366", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Checks on client&#x27;s security policy
 (5_2_3_1_CLIENT_CHECK1) </b><br/><br/> 

Don&#x27;t issue secrets to public clients or clients with inappropriate<br/>security policy
 </td></tr>
   </table>>
   ]

    "Client_Secrets_disclosure_countermeasure0" -> "Client_Secrets_disclosure" [label = " mitigates"]

    "Client_Secrets_disclosure_countermeasure1" [ 
       fillcolor="#D5E8D4", style=filled, shape=polygon, color="#82B366", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Require User Consent for Public Clients without Secret
 (5_2_3_2_USER_CONSENT1) </b><br/><br/> 

Authorization servers should not allow automatic authorization for public<br/>clients.  The authorization server may issue an individual client id but should<br/>require that all authorizations are approved by the end user.  For clients<br/>without secrets, this is a countermeasure against the following threat:   -<br/>Im[...]
 </td></tr>
   </table>>
   ]

    "Client_Secrets_disclosure_countermeasure1" -> "Client_Secrets_disclosure" [label = " mitigates"]

    "Client_Secrets_disclosure_countermeasure2" [ 
       fillcolor="#D5E8D4", style=filled, shape=polygon, color="#82B366", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Issue a &quot;client_id&quot; Only in Combination with &quot;redirect_uri&quot;
 (5_2_3_3_CLIENT_ID_TO_REDIRECT_URI) </b><br/><br/> 

The authorization server may issue a &quot;client_id&quot; and bind the<br/>&quot;client_id&quot; to a certain pre-configured &quot;redirect_uri&quot;.  Any<br/>authorization request with another redirect URI is refused   automatically.<br/>Alternatively, the authorization server should not   accept any dynamic redirect<br/>URI for such a &quot;client_[...]
 </td></tr>
   </table>>
   ]

    "Client_Secrets_disclosure_countermeasure2" -> "Client_Secrets_disclosure" [label = " mitigates"]

    "Client_Secrets_disclosure_countermeasure3" [ 
       fillcolor="#D5E8D4", style=filled, shape=polygon, color="#82B366", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Issue Installation-Specific Client Secrets
 (5_2_3_4_SPECIFIC_CLIENT_SECRETS) </b><br/><br/> 

An authorization server may issue separate client identifiers and corresponding<br/>secrets to the different installations of a particular client (i.e., software<br/>package).  The effect of such an approach would be to turn otherwise<br/>&quot;public&quot; clients back into &quot;confidential&quot; clients. For web<br/>applications, this co[...]
 </td></tr>
   </table>>
   ]

    "Client_Secrets_disclosure_countermeasure3" -> "Client_Secrets_disclosure" [label = " mitigates"]

    "Client_Secrets_disclosure_countermeasure4" [ 
       fillcolor="#FFF2CC", style=filled, shape=polygon, color="#D6B656", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Validate Pre-Registered &quot;redirect_uri&quot;
 (5_2_3_5_VALIDATE_REDIRECT_URI) </b><br/><br/> 

An authorization server should require all clients to register their<br/>&quot;redirect_uri&quot;, and the &quot;redirect_uri&quot; should be the full<br/>URI as defined in [RFC6749].  The way that this registration is performed is out<br/>of scope of this document.  As per the core spec, every actual redirect URI sent<br/>with the respective[...]
 </td></tr>
   </table>>
   ]

    "Client_Secrets_disclosure_countermeasure4" -> "Client_Secrets_disclosure" [label = " mitigates"]



               "Client_Secrets_disclosure" -> "INTEGRITY" [label = " impacts"]
               "4_3_1_EAVESDROPPING_ACCESS_TOKENS1" [ fillcolor="#F8CECC", style=filled, shape=polygon, color="#B85450"
    label= 
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="center"><b>4_3_1_EAVESDROPPING_ACCESS_TOKENS1 ATTACK</b> <br/></td></tr>
     <tr><td align="center">

Attackers may attempt to eavesdrop access tokens in transit from the<br/>authorization server to the client.
</td></tr>
   </table>>
   ];
    

    "4_3_1_EAVESDROPPING_ACCESS_TOKENS1_countermeasure0" [ 
       fillcolor="#FFF2CC", style=filled, shape=polygon, color="#D6B656", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Secure transport layer to CLient to AUTH_SERVER by TLS
 (CLIENT_AUTH_SERVER_TLS) </b><br/><br/> 

As per the core OAuth spec, the authorization servers must ensure that these<br/>transmissions are protected using transport-layer mechanisms such as TLS (see<br/>Section 5.1.1).
 </td></tr>
   </table>>
   ]

    "4_3_1_EAVESDROPPING_ACCESS_TOKENS1_countermeasure0" -> "4_3_1_EAVESDROPPING_ACCESS_TOKENS1" [label = " mitigates"]

    "4_3_1_EAVESDROPPING_ACCESS_TOKENS1_countermeasure1" [ 
       fillcolor="#FFF2CC", style=filled, shape=polygon, color="#D6B656", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Limiting the scope of access tokens obtained through automated approvals
 (REDUCED_ACCESS_TOKEN_SCOPE) </b><br/><br/> 

Authorization servers can mitigate the risks associated with automatic<br/>processing by limiting the scope of access tokens obtained through automated<br/>approvals (Section 5.1.5.1).
 </td></tr>
   </table>>
   ]

    "4_3_1_EAVESDROPPING_ACCESS_TOKENS1_countermeasure1" -> "4_3_1_EAVESDROPPING_ACCESS_TOKENS1" [label = " mitigates"]



               "4_3_1_EAVESDROPPING_ACCESS_TOKENS1" -> "INTEGRITY" [label = " impacts"]
               "4_3_2_AS_DB_TOKEN_DISCLOSURE" [ fillcolor="#F8CECC", style=filled, shape=polygon, color="#B85450"
    label= 
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="center"><b>4_3_2_AS_DB_TOKEN_DISCLOSURE ATTACK</b> <br/></td></tr>
     <tr><td align="center">

An attacker may obtain access tokens from the authorization serverâ€™s database by<br/>gaining access to the database or launching a SQL injection attack.  This threat<br/>is applicable if the authorization server stores access tokens as handles in a<br/>database.
</td></tr>
   </table>>
   ];
    

    "4_3_2_AS_DB_TOKEN_DISCLOSURE_countermeasure0" [ 
       fillcolor="#D5E8D4", style=filled, shape=polygon, color="#82B366", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Store access token hashes only (Section 5.1.4.1.3).
 (5_1_4_1_3_HASHED_TOKEN_DB) </b><br/><br/> 

Store access token hashes only (Section 5.1.4.1.3).
 </td></tr>
   </table>>
   ]

    "4_3_2_AS_DB_TOKEN_DISCLOSURE_countermeasure0" -> "4_3_2_AS_DB_TOKEN_DISCLOSURE" [label = " mitigates"]

    "4_3_2_AS_DB_TOKEN_DISCLOSURE_countermeasure1" [ 
       fillcolor="#FFF2CC", style=filled, shape=polygon, color="#D6B656", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Enforce Standard System Security Means
 (5_1_4_1_1_SYS_SEC) </b><br/><br/> 

A server system may be locked down so that no attacker may get access to<br/>sensitive configuration files and databases.
 </td></tr>
   </table>>
   ]

    "4_3_2_AS_DB_TOKEN_DISCLOSURE_countermeasure1" -> "4_3_2_AS_DB_TOKEN_DISCLOSURE" [label = " mitigates"]

    "4_3_2_AS_DB_TOKEN_DISCLOSURE_countermeasure2" [ 
       fillcolor="#FFF2CC", style=filled, shape=polygon, color="#D6B656", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Enforce Standard SQL Injection Countermeasures
 (5_1_4_1_2_SQL_SEC) </b><br/><br/> 

If a client identifier or other authentication component is queried or compared<br/>against a SQL database, it may become possible for an injection attack to occur<br/>if parameters received are not validated before submission to the database.<br/>&lt;br/&gt;o Ensure that server code is using the minimum database privileges<br/>[...]
 </td></tr>
   </table>>
   ]

    "4_3_2_AS_DB_TOKEN_DISCLOSURE_countermeasure2" -> "4_3_2_AS_DB_TOKEN_DISCLOSURE" [label = " mitigates"]



               "4_3_2_AS_DB_TOKEN_DISCLOSURE" -> "INTEGRITY" [label = " impacts"]
               "4_3_3_CLIENT_CREDENTIALS_DISCLOSURE" [ fillcolor="#F8CECC", style=filled, shape=polygon, color="#B85450"
    label= 
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="center"><b>4_3_3_CLIENT_CREDENTIALS_DISCLOSURE ATTACK</b> <br/></td></tr>
     <tr><td align="center">

An attacker could attempt to eavesdrop the transmission of client credentials<br/>between the client and server during the client authentication process or during<br/>OAuth token requests.
</td></tr>
   </table>>
   ];
    

    "4_3_3_CLIENT_CREDENTIALS_DISCLOSURE_countermeasure0" [ 
       fillcolor="#D5E8D4", style=filled, shape=polygon, color="#82B366", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Ensure Confidentiality of Requests (TLS)
 (5_1_1_CONFIDENTIAL_REQUESTS) </b><br/><br/> 

This is applicable to all requests sent from the client to the authorization<br/>server or resource server. While OAuth provides a mechanism for verifying the<br/>integrity of requests, it provides no guarantee of request confidentiality.<br/>Unless further precautions are taken, eavesdroppers will have full access to<br/>[...]
 </td></tr>
   </table>>
   ]

    "4_3_3_CLIENT_CREDENTIALS_DISCLOSURE_countermeasure0" -> "4_3_3_CLIENT_CREDENTIALS_DISCLOSURE" [label = " mitigates"]

    "4_3_3_CLIENT_CREDENTIALS_DISCLOSURE_countermeasure1" [ 
       fillcolor="#FFF2CC", style=filled, shape=polygon, color="#D6B656", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Do not send plaintext credentials
 (CONFIDENTIAL_CREDENTIALS_REQUESTS) </b><br/><br/> 

Use alternative authentication means that do not require the sending of<br/>plaintext credentials over the wire (e.g., Hash-based Message Authentication<br/>Code).
 </td></tr>
   </table>>
   ]

    "4_3_3_CLIENT_CREDENTIALS_DISCLOSURE_countermeasure1" -> "4_3_3_CLIENT_CREDENTIALS_DISCLOSURE" [label = " mitigates"]



               "4_3_3_CLIENT_CREDENTIALS_DISCLOSURE" -> "INTEGRITY" [label = " impacts"]
               "4_3_4_CLIENT_CREDENTIALS_DISCLOSURE" [ fillcolor="#F8CECC", style=filled, shape=polygon, color="#B85450"
    label= 
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="center"><b>4_3_4_CLIENT_CREDENTIALS_DISCLOSURE ATTACK</b> <br/></td></tr>
     <tr><td align="center">

An attacker may obtain valid &quot;client_id&quot;/secret combinations from the<br/>authorization serverâ€™s database by gaining access to the database or launching a<br/>SQL injection attack.
</td></tr>
   </table>>
   ];
    

    "4_3_4_CLIENT_CREDENTIALS_DISCLOSURE_countermeasure0" [ 
       fillcolor="#FFF2CC", style=filled, shape=polygon, color="#D6B656", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Enforce Standard SQL Injection Countermeasures
 (5_1_4_1_2_SQL_SEC) </b><br/><br/> 

If a client identifier or other authentication component is queried or compared<br/>against a SQL database, it may become possible for an injection attack to occur<br/>if parameters received are not validated before submission to the database.<br/>&lt;br/&gt;o Ensure that server code is using the minimum database privileges<br/>[...]
 </td></tr>
   </table>>
   ]

    "4_3_4_CLIENT_CREDENTIALS_DISCLOSURE_countermeasure0" -> "4_3_4_CLIENT_CREDENTIALS_DISCLOSURE" [label = " mitigates"]

    "4_3_4_CLIENT_CREDENTIALS_DISCLOSURE_countermeasure1" [ 
       fillcolor="#FFF2CC", style=filled, shape=polygon, color="#D6B656", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Enforce Standard System Security Means
 (5_1_4_1_1_SYS_SEC) </b><br/><br/> 

A server system may be locked down so that no attacker may get access to<br/>sensitive configuration files and databases.
 </td></tr>
   </table>>
   ]

    "4_3_4_CLIENT_CREDENTIALS_DISCLOSURE_countermeasure1" -> "4_3_4_CLIENT_CREDENTIALS_DISCLOSURE" [label = " mitigates"]

    "4_3_4_CLIENT_CREDENTIALS_DISCLOSURE_countermeasure2" [ 
       fillcolor="#FFF2CC", style=filled, shape=polygon, color="#D6B656", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Enforce Credential Storage Protection Best Practices
 (5_1_4_1_CRED_PROTECTION) </b><br/><br/> 

Administrators should undertake industry best practices to protect the storage<br/>of credentials (for example, see [OWASP]). Such practices may include but are<br/>not limited to the following sub-sections.
 </td></tr>
   </table>>
   ]

    "4_3_4_CLIENT_CREDENTIALS_DISCLOSURE_countermeasure2" -> "4_3_4_CLIENT_CREDENTIALS_DISCLOSURE" [label = " mitigates"]



               "4_3_4_CLIENT_CREDENTIALS_DISCLOSURE" -> "INTEGRITY" [label = " impacts"]
               "4_3_5_CLIENT_SECRET_BRUTE_FORCE" [ fillcolor="#F8CECC", style=filled, shape=polygon, color="#B85450"
    label= 
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="center"><b>4_3_5_CLIENT_SECRET_BRUTE_FORCE ATTACK</b> <br/></td></tr>
     <tr><td align="center">

An attacker may try to guess valid &quot;client_id&quot;/secret pairs.
</td></tr>
   </table>>
   ];
    

    "4_3_5_CLIENT_SECRET_BRUTE_FORCE_countermeasure0" [ 
       fillcolor="#FFF2CC", style=filled, shape=polygon, color="#D6B656", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Use High Entropy for Secrets
 (5_1_4_2_2_HIGH_ENTROPY_SECRETS) </b><br/><br/> 

When creating secrets not intended for usage by human users (e.g., client<br/>secrets or token handles), the authorization server should include a reasonable<br/>level of entropy in order to mitigate the risk of guessing attacks. The token<br/>value should be &gt;=128 bits long and constructed from a cryptographically<br/>str[...]
 </td></tr>
   </table>>
   ]

    "4_3_5_CLIENT_SECRET_BRUTE_FORCE_countermeasure0" -> "4_3_5_CLIENT_SECRET_BRUTE_FORCE" [label = " mitigates"]

    "4_3_5_CLIENT_SECRET_BRUTE_FORCE_countermeasure1" [ 
       fillcolor="#FFF2CC", style=filled, shape=polygon, color="#D6B656", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Lock Accounts
 (5_1_4_2_3_LOCK_ACCOUNTS) </b><br/><br/> 

Online attacks on passwords can be mitigated by locking the respective accounts<br/>after a certain number of failed attempts. Note: This measure can be abused to<br/>lock down legitimate service users.
 </td></tr>
   </table>>
   ]

    "4_3_5_CLIENT_SECRET_BRUTE_FORCE_countermeasure1" -> "4_3_5_CLIENT_SECRET_BRUTE_FORCE" [label = " mitigates"]

    "4_3_5_CLIENT_SECRET_BRUTE_FORCE_countermeasure2" [ 
       fillcolor="#FFF2CC", style=filled, shape=polygon, color="#D6B656", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Use strong client authentication
 (5_2_3_7_STRONG_CLIENT_AUTHENTICATION) </b><br/><br/> 

By using an alternative form of authentication such as client assertion [OAuth-<br/>ASSERTIONS], the need to distribute a &quot;client_secret&quot; is eliminated.<br/>This may require the use of a secure private key store or other supplemental<br/>authentication system as specified by the client assertion issuer in its<br/>authentica[...]
 </td></tr>
   </table>>
   ]

    "4_3_5_CLIENT_SECRET_BRUTE_FORCE_countermeasure2" -> "4_3_5_CLIENT_SECRET_BRUTE_FORCE" [label = " mitigates"]



               "4_3_5_CLIENT_SECRET_BRUTE_FORCE" -> "INTEGRITY" [label = " impacts"]
               "4_4_1_1_AUTH_CODE_DISCLOSURE" [ fillcolor="#F8CECC", style=filled, shape=polygon, color="#B85450"
    label= 
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="center"><b>4_4_1_1_AUTH_CODE_DISCLOSURE ATTACK</b> <br/></td></tr>
     <tr><td align="center">

An attacker could try to eavesdrop transmission of the authorization<br/>&quot;code&quot; between the authorization server and client. Furthermore,<br/>authorization &quot;codes&quot; are passed via the browser, which may<br/>unintentionally leak those codes to untrusted web sites and attackers in<br/>different ways: &lt;br/&gt;o Referrer headers: [...]
</td></tr>
   </table>>
   ];
    

    "4_4_1_1_AUTH_CODE_DISCLOSURE_countermeasure0" [ 
       fillcolor="#D5E8D4", style=filled, shape=polygon, color="#82B366", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Ensure Confidentiality of Requests (TLS)
 (5_1_1_CONFIDENTIAL_REQUESTS) </b><br/><br/> 

This is applicable to all requests sent from the client to the authorization<br/>server or resource server. While OAuth provides a mechanism for verifying the<br/>integrity of requests, it provides no guarantee of request confidentiality.<br/>Unless further precautions are taken, eavesdroppers will have full access to<br/>[...]
 </td></tr>
   </table>>
   ]

    "4_4_1_1_AUTH_CODE_DISCLOSURE_countermeasure0" -> "4_4_1_1_AUTH_CODE_DISCLOSURE" [label = " mitigates"]

    "4_4_1_1_AUTH_CODE_DISCLOSURE_countermeasure1" [ 
       fillcolor="#D5E8D4", style=filled, shape=polygon, color="#82B366", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Binding of Authorization &quot;code&quot; to &quot;client_id&quot;
 (5_2_4_4_CLIENT_TO_CODE_BINDING) </b><br/><br/> 

The authorization server should bind every authorization &quot;code&quot; to the<br/>id of the respective client that initiated the end-user authorization process.<br/>This measure is a countermeasure against: &lt;br/&gt;o Replay of authorization<br/>&quot;codes&quot; with different client credentials, since an attacker cannot<br/>use another &quot;clie[...]
 </td></tr>
   </table>>
   ]

    "4_4_1_1_AUTH_CODE_DISCLOSURE_countermeasure1" -> "4_4_1_1_AUTH_CODE_DISCLOSURE" [label = " mitigates"]

    "4_4_1_1_AUTH_CODE_DISCLOSURE_countermeasure2" [ 
       fillcolor="#FFF2CC", style=filled, shape=polygon, color="#D6B656", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Use Short Expiration Time
 (5_1_5_3_SHORT_EXPIRY_CODE) </b><br/><br/> 

A short expiration time for tokens is a means of protection against the<br/>following threats: &lt;br/&gt;o replay &lt;br/&gt;o token leak (a short<br/>expiration time will reduce impact) &lt;br/&gt;o online guessing (a short<br/>expiration time will reduce the likelihood of success) Note: Short token<br/>duration requires more precise cloc[...]
 </td></tr>
   </table>>
   ]

    "4_4_1_1_AUTH_CODE_DISCLOSURE_countermeasure2" -> "4_4_1_1_AUTH_CODE_DISCLOSURE" [label = " mitigates"]

    "4_4_1_1_AUTH_CODE_DISCLOSURE_countermeasure3" [ 
       fillcolor="#FFF2CC", style=filled, shape=polygon, color="#D6B656", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Limit Number of Usages or One-Time Usage
 (5_1_5_4_ONE_TIME_USE_TOKEN) </b><br/><br/> 

The authorization server may restrict the number of requests or operations that<br/>can be performed with a certain token. This mechanism can be used to mitigate<br/>the following threats: &lt;br/&gt;o replay of tokens &lt;br/&gt;o guessing For<br/>example, if an authorization server observes more than one attempt to redeem an<br/>aut[...]
 </td></tr>
   </table>>
   ]

    "4_4_1_1_AUTH_CODE_DISCLOSURE_countermeasure3" -> "4_4_1_1_AUTH_CODE_DISCLOSURE" [label = " mitigates"]

    "4_4_1_1_AUTH_CODE_DISCLOSURE_countermeasure4" [ 
       fillcolor="#FFF2CC", style=filled, shape=polygon, color="#D6B656", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Automatic Revocation of Derived Tokens If Abuse Is Detected
 (5_2_1_1_TOKEN_ABUSE_DETECTION) </b><br/><br/> 

If an authorization server observes multiple attempts to redeem an authorization<br/>grant (e.g., such as an authorization &quot;code&quot;), the authorization<br/>server may want to revoke all tokens granted based on the authorization grant
 </td></tr>
   </table>>
   ]

    "4_4_1_1_AUTH_CODE_DISCLOSURE_countermeasure4" -> "4_4_1_1_AUTH_CODE_DISCLOSURE" [label = " mitigates"]

    "4_4_1_1_AUTH_CODE_DISCLOSURE_countermeasure5" [ 
       fillcolor="#FFF2CC", style=filled, shape=polygon, color="#D6B656", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Reload the target page
 (USER_AGENT_PAGE_RELOAD) </b><br/><br/> 

The client server may reload the target page of the redirect URI in order to<br/>automatically clean up the browser cache.
 </td></tr>
   </table>>
   ]

    "4_4_1_1_AUTH_CODE_DISCLOSURE_countermeasure5" -> "4_4_1_1_AUTH_CODE_DISCLOSURE" [label = " mitigates"]



               "4_4_1_1_AUTH_CODE_DISCLOSURE" -> "INTEGRITY" [label = " impacts"]
               "4_4_1_2_AUTH_CODE_DISCLOSURE_DB" [ fillcolor="#F8CECC", style=filled, shape=polygon, color="#B85450"
    label= 
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="center"><b>4_4_1_2_AUTH_CODE_DISCLOSURE_DB ATTACK</b> <br/></td></tr>
     <tr><td align="center">

This threat is applicable if the authorization server stores  authorization<br/>&quot;codes&quot; as handles in a database. An attacker may  obtain<br/>authorization &quot;codes&quot; from the authorization serverâ€™s database  by<br/>gaining access to the database or launching a SQL injection  attack.
</td></tr>
   </table>>
   ];
    

    "4_4_1_2_AUTH_CODE_DISCLOSURE_DB_countermeasure0" [ 
       fillcolor="#FFF2CC", style=filled, shape=polygon, color="#D6B656", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Enforce Standard System Security Means
 (5_1_4_1_1_SYS_SEC) </b><br/><br/> 

A server system may be locked down so that no attacker may get access to<br/>sensitive configuration files and databases.
 </td></tr>
   </table>>
   ]

    "4_4_1_2_AUTH_CODE_DISCLOSURE_DB_countermeasure0" -> "4_4_1_2_AUTH_CODE_DISCLOSURE_DB" [label = " mitigates"]

    "4_4_1_2_AUTH_CODE_DISCLOSURE_DB_countermeasure1" [ 
       fillcolor="#FFF2CC", style=filled, shape=polygon, color="#D6B656", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Enforce Standard SQL Injection Countermeasures
 (5_1_4_1_2_SQL_SEC) </b><br/><br/> 

If a client identifier or other authentication component is queried or compared<br/>against a SQL database, it may become possible for an injection attack to occur<br/>if parameters received are not validated before submission to the database.<br/>&lt;br/&gt;o Ensure that server code is using the minimum database privileges<br/>[...]
 </td></tr>
   </table>>
   ]

    "4_4_1_2_AUTH_CODE_DISCLOSURE_DB_countermeasure1" -> "4_4_1_2_AUTH_CODE_DISCLOSURE_DB" [label = " mitigates"]

    "4_4_1_2_AUTH_CODE_DISCLOSURE_DB_countermeasure2" [ 
       fillcolor="#D5E8D4", style=filled, shape=polygon, color="#82B366", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Store access token hashes only (Section 5.1.4.1.3).
 (5_1_4_1_3_HASHED_TOKEN_DB) </b><br/><br/> 

Store access token hashes only (Section 5.1.4.1.3).
 </td></tr>
   </table>>
   ]

    "4_4_1_2_AUTH_CODE_DISCLOSURE_DB_countermeasure2" -> "4_4_1_2_AUTH_CODE_DISCLOSURE_DB" [label = " mitigates"]



               "4_4_1_2_AUTH_CODE_DISCLOSURE_DB" -> "INTEGRITY" [label = " impacts"]
               "4_4_1_3_AUTH_CODE_BRUTE_FORCE" [ fillcolor="#F8CECC", style=filled, shape=polygon, color="#B85450"
    label= 
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="center"><b>4_4_1_3_AUTH_CODE_BRUTE_FORCE ATTACK</b> <br/></td></tr>
     <tr><td align="center">

An attacker may try to guess valid authorization &quot;code&quot; values and<br/>send the guessed code value using the grant type &quot;code&quot; in order to<br/>obtain a valid access token.
</td></tr>
   </table>>
   ];
    

    "4_4_1_3_AUTH_CODE_BRUTE_FORCE_countermeasure0" [ 
       fillcolor="#FFF2CC", style=filled, shape=polygon, color="#D6B656", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Use High Entropy for Secrets
 (5_1_4_2_2_HIGH_ENTROPY_SECRETS) </b><br/><br/> 

When creating secrets not intended for usage by human users (e.g., client<br/>secrets or token handles), the authorization server should include a reasonable<br/>level of entropy in order to mitigate the risk of guessing attacks. The token<br/>value should be &gt;=128 bits long and constructed from a cryptographically<br/>str[...]
 </td></tr>
   </table>>
   ]

    "4_4_1_3_AUTH_CODE_BRUTE_FORCE_countermeasure0" -> "4_4_1_3_AUTH_CODE_BRUTE_FORCE" [label = " mitigates"]

    "4_4_1_3_AUTH_CODE_BRUTE_FORCE_countermeasure1" [ 
       fillcolor="#FFF2CC", style=filled, shape=polygon, color="#D6B656", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Sign Self-Contained Tokens
 (5_1_5_9_SIGNED_TOKEN) </b><br/><br/> 

Self-contained tokens should be signed in order to detect any attempt to modify<br/>or produce faked tokens (e.g., Hash-based Message Authentication Code or digital<br/>signatures).
 </td></tr>
   </table>>
   ]

    "4_4_1_3_AUTH_CODE_BRUTE_FORCE_countermeasure1" -> "4_4_1_3_AUTH_CODE_BRUTE_FORCE" [label = " mitigates"]

    "4_4_1_3_AUTH_CODE_BRUTE_FORCE_countermeasure2" [ 
       fillcolor="#D5E8D4", style=filled, shape=polygon, color="#82B366", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Issue Installation-Specific Client Secrets
 (5_2_3_4_SPECIFIC_CLIENT_SECRETS) </b><br/><br/> 

An authorization server may issue separate client identifiers and corresponding<br/>secrets to the different installations of a particular client (i.e., software<br/>package).  The effect of such an approach would be to turn otherwise<br/>&quot;public&quot; clients back into &quot;confidential&quot; clients. For web<br/>applications, this co[...]
 </td></tr>
   </table>>
   ]

    "4_4_1_3_AUTH_CODE_BRUTE_FORCE_countermeasure2" -> "4_4_1_3_AUTH_CODE_BRUTE_FORCE" [label = " mitigates"]

    "4_4_1_3_AUTH_CODE_BRUTE_FORCE_countermeasure3" [ 
       fillcolor="#FFF2CC", style=filled, shape=polygon, color="#D6B656", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Binding of Authorization &quot;code&quot; to &quot;redirect_uri&quot;
 (5_2_4_5_REDIRECT_CODE_BINDING) </b><br/><br/> 

The authorization server should be able to bind every authorization<br/>&quot;code&quot; to the actual redirect URI used as the redirect target of the<br/>client in the end-user authorization process. This binding should be validated<br/>when the client attempts to exchange the respective authorization<br/>&quot;code&quot; for an access token[...]
 </td></tr>
   </table>>
   ]

    "4_4_1_3_AUTH_CODE_BRUTE_FORCE_countermeasure3" -> "4_4_1_3_AUTH_CODE_BRUTE_FORCE" [label = " mitigates"]

    "4_4_1_3_AUTH_CODE_BRUTE_FORCE_countermeasure4" [ 
       fillcolor="#FFF2CC", style=filled, shape=polygon, color="#D6B656", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Use Short Expiration Time
 (5_1_5_3_SHORT_EXPIRY_CODE) </b><br/><br/> 

A short expiration time for tokens is a means of protection against the<br/>following threats: &lt;br/&gt;o replay &lt;br/&gt;o token leak (a short<br/>expiration time will reduce impact) &lt;br/&gt;o online guessing (a short<br/>expiration time will reduce the likelihood of success) Note: Short token<br/>duration requires more precise cloc[...]
 </td></tr>
   </table>>
   ]

    "4_4_1_3_AUTH_CODE_BRUTE_FORCE_countermeasure4" -> "4_4_1_3_AUTH_CODE_BRUTE_FORCE" [label = " mitigates"]



               "4_4_1_3_AUTH_CODE_BRUTE_FORCE" -> "INTEGRITY" [label = " impacts"]
               "4_4_1_4_CLIENT_SPOOFING1" [ fillcolor="#F8CECC", style=filled, shape=polygon, color="#B85450"
    label= 
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="center"><b>4_4_1_4_CLIENT_SPOOFING1 ATTACK</b> <br/></td></tr>
     <tr><td align="center">

A malicious client could pretend to be a valid client and obtain an access<br/>authorization in this way. The malicious client could even utilize screen-<br/>scraping techniques in order to simulate a userâ€™s consent in the authorization<br/>flow.
</td></tr>
   </table>>
   ];
    

    "4_4_1_4_CLIENT_SPOOFING1_countermeasure0" [ 
       fillcolor="#D5E8D4", style=filled, shape=polygon, color="#82B366", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Issue Installation-Specific Client Secrets
 (5_2_3_4_SPECIFIC_CLIENT_SECRETS) </b><br/><br/> 

An authorization server may issue separate client identifiers and corresponding<br/>secrets to the different installations of a particular client (i.e., software<br/>package).  The effect of such an approach would be to turn otherwise<br/>&quot;public&quot; clients back into &quot;confidential&quot; clients. For web<br/>applications, this co[...]
 </td></tr>
   </table>>
   ]

    "4_4_1_4_CLIENT_SPOOFING1_countermeasure0" -> "4_4_1_4_CLIENT_SPOOFING1" [label = " mitigates"]

    "4_4_1_4_CLIENT_SPOOFING1_countermeasure1" [ 
       fillcolor="#FFF2CC", style=filled, shape=polygon, color="#D6B656", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Validate Pre-Registered &quot;redirect_uri&quot;
 (5_2_3_5_VALIDATE_REDIRECT_URI) </b><br/><br/> 

An authorization server should require all clients to register their<br/>&quot;redirect_uri&quot;, and the &quot;redirect_uri&quot; should be the full<br/>URI as defined in [RFC6749].  The way that this registration is performed is out<br/>of scope of this document.  As per the core spec, every actual redirect URI sent<br/>with the respective[...]
 </td></tr>
   </table>>
   ]

    "4_4_1_4_CLIENT_SPOOFING1_countermeasure1" -> "4_4_1_4_CLIENT_SPOOFING1" [label = " mitigates"]

    "4_4_1_4_CLIENT_SPOOFING1_countermeasure2" [ 
       fillcolor="#FFF2CC", style=filled, shape=polygon, color="#D6B656", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Validation of Client Properties by End User
 (5_2_4_3_VALIDATION_OF_CLIENT_BY_END_USER) </b><br/><br/> 

In the authorization process, the user is typically asked to approve a clientâ€™s<br/>request for authorization. This is an important security mechanism by itself<br/>because the end user can be involved in the validation of client properties,<br/>such as whether the client name known to the authorization server fits the[...]
 </td></tr>
   </table>>
   ]

    "4_4_1_4_CLIENT_SPOOFING1_countermeasure2" -> "4_4_1_4_CLIENT_SPOOFING1" [label = " mitigates"]

    "4_4_1_4_CLIENT_SPOOFING1_countermeasure3" [ 
       fillcolor="#FFF2CC", style=filled, shape=polygon, color="#D6B656", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Automatic Processing of Repeated Authorizations Requires Client Validation
 (5_2_4_1_REPEAT_VALIDATE_CLIENT) </b><br/><br/> 

Authorization servers should NOT automatically process repeat authorizations<br/>where the client is not authenticated through a client secret or some other<br/>authentication mechanism such as a signed authentication assertion certificate<br/>(Section 5.2.3.7) or validation of a pre-registered redirect URI (Section<br/>5.[...]
 </td></tr>
   </table>>
   ]

    "4_4_1_4_CLIENT_SPOOFING1_countermeasure3" -> "4_4_1_4_CLIENT_SPOOFING1" [label = " mitigates"]

    "4_4_1_4_CLIENT_SPOOFING1_countermeasure4" [ 
       fillcolor="#FFF2CC", style=filled, shape=polygon, color="#D6B656", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Automatic Processing of Repeated Authorizations Requires Client Validation
 (REQUIRE_USER_MANUAL_STEP) </b><br/><br/> 

If the authorization server automatically authenticates the end user, it may<br/>nevertheless require some user input in order to prevent screen scraping.<br/>Examples are CAPTCHAs (Completely Automated Public Turing tests to tell<br/>Computers and Humans Apart) or other multi-factor authentication techniques such<br/>as r[...]
 </td></tr>
   </table>>
   ]

    "4_4_1_4_CLIENT_SPOOFING1_countermeasure4" -> "4_4_1_4_CLIENT_SPOOFING1" [label = " mitigates"]

    "4_4_1_4_CLIENT_SPOOFING1_countermeasure5" [ 
       fillcolor="#FFF2CC", style=filled, shape=polygon, color="#D6B656", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Limit Token Scope
 (5_1_5_1_LIMITED_SCOPE_TOKEN) </b><br/><br/> 

The authorization server may decide to reduce or limit the scope associated with<br/>a token. The basis of this decision is out of scope; examples are: &lt;br/&gt;o<br/>a client-specific policy, e.g., issue only less powerful tokens to public<br/>clients, &lt;br/&gt;o a service-specific policy, e.g., it is a very sensitive<br/>servic[...]
 </td></tr>
   </table>>
   ]

    "4_4_1_4_CLIENT_SPOOFING1_countermeasure5" -> "4_4_1_4_CLIENT_SPOOFING1" [label = " mitigates"]



               "4_4_1_4_CLIENT_SPOOFING1" -> "INTEGRITY" [label = " impacts"]
               "4_4_1_5_CLIENT_SPOOFING2" [ fillcolor="#F8CECC", style=filled, shape=polygon, color="#B85450"
    label= 
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="center"><b>4_4_1_5_CLIENT_SPOOFING2 ATTACK</b> <br/></td></tr>
     <tr><td align="center">

A hostile party could impersonate the client site and get access to the<br/>authorization &quot;code&quot;. This could be achieved using DNS or ARP<br/>spoofing. This applies to clients, which are web applications; thus, the<br/>redirect URI is not local to the host where the userâ€™s browser is running.
</td></tr>
   </table>>
   ];
    

    "4_4_1_5_CLIENT_SPOOFING2_countermeasure0" [ 
       fillcolor="#D5E8D4", style=filled, shape=polygon, color="#82B366", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

TLS for the authorization server
 (5_1_2_AUTH_SERVER_AUTHENTICATION) </b><br/><br/> 

Authorization servers should consider such attacks when developing services<br/>based on OAuth and should require the use of transport- layer security for any<br/>requests where the authenticity of the authorization server or of request<br/>responses is an issue (see Section 5.1.2). HTTPS server authentication or<br/>simi[...]
 </td></tr>
   </table>>
   ]

    "4_4_1_5_CLIENT_SPOOFING2_countermeasure0" -> "4_4_1_5_CLIENT_SPOOFING2" [label = " mitigates"]

    "4_4_1_5_CLIENT_SPOOFING2_countermeasure1" [ 
       fillcolor="#D5E8D4", style=filled, shape=polygon, color="#82B366", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Binding of Authorization &quot;code&quot; to &quot;client_id&quot;
 (5_2_4_4_CLIENT_TO_CODE_BINDING) </b><br/><br/> 

The authorization server should bind every authorization &quot;code&quot; to the<br/>id of the respective client that initiated the end-user authorization process.<br/>This measure is a countermeasure against: &lt;br/&gt;o Replay of authorization<br/>&quot;codes&quot; with different client credentials, since an attacker cannot<br/>use another &quot;clie[...]
 </td></tr>
   </table>>
   ]

    "4_4_1_5_CLIENT_SPOOFING2_countermeasure1" -> "4_4_1_5_CLIENT_SPOOFING2" [label = " mitigates"]



               "4_4_1_5_CLIENT_SPOOFING2" -> "INTEGRITY" [label = " impacts"]
               "4_4_1_6_CLIENT_SPOOFING3" [ fillcolor="#F8CECC", style=filled, shape=polygon, color="#B85450"
    label= 
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="center"><b>4_4_1_6_CLIENT_SPOOFING3 ATTACK</b> <br/></td></tr>
     <tr><td align="center">

A hostile party could impersonate the client site and impersonate the userâ€™s<br/>session on this client. This could be achieved using DNS or ARP spoofing. This<br/>applies to clients, which are web applications; thus, the redirect URI is not<br/>local to the host where the userâ€™s browser is running.
</td></tr>
   </table>>
   ];
    

    "4_4_1_6_CLIENT_SPOOFING3_countermeasure0" [ 
       fillcolor="#D5E8D4", style=filled, shape=polygon, color="#82B366", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

TLS for the authorization server
 (5_1_2_AUTH_SERVER_AUTHENTICATION) </b><br/><br/> 

Authorization servers should consider such attacks when developing services<br/>based on OAuth and should require the use of transport- layer security for any<br/>requests where the authenticity of the authorization server or of request<br/>responses is an issue (see Section 5.1.2). HTTPS server authentication or<br/>simi[...]
 </td></tr>
   </table>>
   ]

    "4_4_1_6_CLIENT_SPOOFING3_countermeasure0" -> "4_4_1_6_CLIENT_SPOOFING3" [label = " mitigates"]



               "4_4_1_6_CLIENT_SPOOFING3" -> "INTEGRITY" [label = " impacts"]
               "4_4_1_7_CLIENT_SPOOFING4" [ fillcolor="#F8CECC", style=filled, shape=polygon, color="#B85450"
    label= 
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="center"><b>4_4_1_7_CLIENT_SPOOFING4 ATTACK</b> <br/></td></tr>
     <tr><td align="center">

The attacker leverages the authorization &quot;code&quot; grant type in an<br/>attempt to get another user (victim) to log in, authorize access to his/her<br/>resources, and subsequently obtain the authorization &quot;code&quot; and inject<br/>it into a client application using the attackerâ€™s account. The goal is to<br/>associate an access au[...]
</td></tr>
   </table>>
   ];
    

    "4_4_1_7_CLIENT_SPOOFING4_countermeasure0" [ 
       fillcolor="#FFF2CC", style=filled, shape=polygon, color="#D6B656", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Binding of Authorization &quot;code&quot; to &quot;redirect_uri&quot;
 (5_2_4_5_REDIRECT_CODE_BINDING) </b><br/><br/> 

The authorization server should be able to bind every authorization<br/>&quot;code&quot; to the actual redirect URI used as the redirect target of the<br/>client in the end-user authorization process. This binding should be validated<br/>when the client attempts to exchange the respective authorization<br/>&quot;code&quot; for an access token[...]
 </td></tr>
   </table>>
   ]

    "4_4_1_7_CLIENT_SPOOFING4_countermeasure0" -> "4_4_1_7_CLIENT_SPOOFING4" [label = " mitigates"]

    "4_4_1_7_CLIENT_SPOOFING4_countermeasure1" [ 
       fillcolor="#D5E8D4", style=filled, shape=polygon, color="#82B366", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Issue Installation-Specific Client Secrets
 (5_2_3_4_SPECIFIC_CLIENT_SECRETS) </b><br/><br/> 

An authorization server may issue separate client identifiers and corresponding<br/>secrets to the different installations of a particular client (i.e., software<br/>package).  The effect of such an approach would be to turn otherwise<br/>&quot;public&quot; clients back into &quot;confidential&quot; clients. For web<br/>applications, this co[...]
 </td></tr>
   </table>>
   ]

    "4_4_1_7_CLIENT_SPOOFING4_countermeasure1" -> "4_4_1_7_CLIENT_SPOOFING4" [label = " mitigates"]

    "4_4_1_7_CLIENT_SPOOFING4_countermeasure2" [ 
       fillcolor="#D5E8D4", style=filled, shape=polygon, color="#82B366", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Binding of Authorization &quot;code&quot; to &quot;client_id&quot;
 (5_2_4_4_CLIENT_TO_CODE_BINDING) </b><br/><br/> 

The authorization server should bind every authorization &quot;code&quot; to the<br/>id of the respective client that initiated the end-user authorization process.<br/>This measure is a countermeasure against: &lt;br/&gt;o Replay of authorization<br/>&quot;codes&quot; with different client credentials, since an attacker cannot<br/>use another &quot;clie[...]
 </td></tr>
   </table>>
   ]

    "4_4_1_7_CLIENT_SPOOFING4_countermeasure2" -> "4_4_1_7_CLIENT_SPOOFING4" [label = " mitigates"]

    "4_4_1_7_CLIENT_SPOOFING4_countermeasure3" [ 
       fillcolor="#FFF2CC", style=filled, shape=polygon, color="#D6B656", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Implicit grant flow
 (IMPLICIT_GRANT_FLOW) </b><br/><br/> 

The client may consider using other flows that are not vulnerable to this kind<br/>of attack, such as the implicit grant type (see Section 4.4.2) or resource owner<br/>password credentials (see Section 4.4.3).
 </td></tr>
   </table>>
   ]

    "4_4_1_7_CLIENT_SPOOFING4_countermeasure3" -> "4_4_1_7_CLIENT_SPOOFING4" [label = " mitigates"]



               "4_4_1_7_CLIENT_SPOOFING4" -> "INTEGRITY" [label = " impacts"]
               "4_4_1_13_CODE_SUBSTITUTION" [ fillcolor="#F8CECC", style=filled, shape=polygon, color="#B85450"
    label= 
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="center"><b>4_4_1_13_CODE_SUBSTITUTION ATTACK</b> <br/></td></tr>
     <tr><td align="center">

An attacker could attempt to log into an application or web site  using a<br/>victimâ€™s identity. Applications relying on identity data  provided by an OAuth<br/>protected service API to login users are  vulnerable to this threat. This<br/>pattern can be found in so-called  &quot;social login&quot; scenarios.  As a<br/>prerequisite, [...]
</td></tr>
   </table>>
   ];
    

    "4_4_1_13_CODE_SUBSTITUTION_countermeasure0" [ 
       fillcolor="#FFF2CC", style=filled, shape=polygon, color="#D6B656", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Clients indicate their ids in requests
 (IN_REQUEST_CLIENTID) </b><br/><br/> 

All clients must indicate their client ids with every request to exchange an<br/>authorization &quot;code&quot; for an access token. The authorization server<br/>must validate whether the particular authorization &quot;code&quot; has been<br/>issued to the particular client. If possible, the client shall be authenticated<br/>beforehand.
 </td></tr>
   </table>>
   ]

    "4_4_1_13_CODE_SUBSTITUTION_countermeasure0" -> "4_4_1_13_CODE_SUBSTITUTION" [label = " mitigates"]

    "4_4_1_13_CODE_SUBSTITUTION_countermeasure1" [ 
       fillcolor="#FFF2CC", style=filled, shape=polygon, color="#D6B656", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Secure User Login Protocol
 (SECURE_USER_LOGIN_PROTOCOL) </b><br/><br/> 

Clients should use an appropriate protocol, such as OpenID (cf. [OPENID]) or<br/>SAML (cf. [OASIS.sstc-saml-bindings-1.1]) to implement user login. Both support<br/>audience restrictions on clients.
 </td></tr>
   </table>>
   ]

    "4_4_1_13_CODE_SUBSTITUTION_countermeasure1" -> "4_4_1_13_CODE_SUBSTITUTION" [label = " mitigates"]



               "4_4_1_13_CODE_SUBSTITUTION" -> "INTEGRITY" [label = " impacts"]
               "4_4_2_1_TOKEN_LEAK1_NETWORK" [ fillcolor="#F8CECC", style=filled, shape=polygon, color="#B85450"
    label= 
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="center"><b>4_4_2_1_TOKEN_LEAK1_NETWORK ATTACK</b> <br/></td></tr>
     <tr><td align="center">

This token might be eavesdropped by an attacker. The token is sent from the<br/>server to the client via a URI fragment of the redirect URI. If the<br/>communication is not secured or the endpoint is not secured, the token could be<br/>leaked by parsing the returned URI.
</td></tr>
   </table>>
   ];
    

    "4_4_2_1_TOKEN_LEAK1_NETWORK_countermeasure0" [ 
       fillcolor="#D5E8D4", style=filled, shape=polygon, color="#82B366", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Ensure Confidentiality of Requests (TLS)
 (5_1_1_CONFIDENTIAL_REQUESTS) </b><br/><br/> 

This is applicable to all requests sent from the client to the authorization<br/>server or resource server. While OAuth provides a mechanism for verifying the<br/>integrity of requests, it provides no guarantee of request confidentiality.<br/>Unless further precautions are taken, eavesdroppers will have full access to<br/>[...]
 </td></tr>
   </table>>
   ]

    "4_4_2_1_TOKEN_LEAK1_NETWORK_countermeasure0" -> "4_4_2_1_TOKEN_LEAK1_NETWORK" [label = " mitigates"]



               "4_4_2_1_TOKEN_LEAK1_NETWORK" -> "INTEGRITY" [label = " impacts"]
               "4_4_2_2_TOKEN_LEAK2_BROWSER_HISTORY" [ fillcolor="#F8CECC", style=filled, shape=polygon, color="#B85450"
    label= 
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="center"><b>4_4_2_2_TOKEN_LEAK2_BROWSER_HISTORY ATTACK</b> <br/></td></tr>
     <tr><td align="center">

An attacker could obtain the token from the browserâ€™s history. Note that this<br/>means the attacker needs access to the particular device.
</td></tr>
   </table>>
   ];
    

    "4_4_2_2_TOKEN_LEAK2_BROWSER_HISTORY_countermeasure0" [ 
       fillcolor="#FFF2CC", style=filled, shape=polygon, color="#D6B656", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Use Short Expiration Time
 (5_1_5_3_SHORT_EXPIRY_CODE) </b><br/><br/> 

A short expiration time for tokens is a means of protection against the<br/>following threats: &lt;br/&gt;o replay &lt;br/&gt;o token leak (a short<br/>expiration time will reduce impact) &lt;br/&gt;o online guessing (a short<br/>expiration time will reduce the likelihood of success) Note: Short token<br/>duration requires more precise cloc[...]
 </td></tr>
   </table>>
   ]

    "4_4_2_2_TOKEN_LEAK2_BROWSER_HISTORY_countermeasure0" -> "4_4_2_2_TOKEN_LEAK2_BROWSER_HISTORY" [label = " mitigates"]

    "4_4_2_2_TOKEN_LEAK2_BROWSER_HISTORY_countermeasure1" [ 
       fillcolor="#FFF2CC", style=filled, shape=polygon, color="#D6B656", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Make responses non-cacheable.
 (NON_CACHEABLE_RESPONSES) </b><br/><br/> 

Make responses non-cacheable.
 </td></tr>
   </table>>
   ]

    "4_4_2_2_TOKEN_LEAK2_BROWSER_HISTORY_countermeasure1" -> "4_4_2_2_TOKEN_LEAK2_BROWSER_HISTORY" [label = " mitigates"]



               "4_4_2_2_TOKEN_LEAK2_BROWSER_HISTORY" -> "INTEGRITY" [label = " impacts"]
               "4_4_2_2_TOKEN_LEAK2_BROWSER_HISTORY" [ fillcolor="#F8CECC", style=filled, shape=polygon, color="#B85450"
    label= 
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="center"><b>4_4_2_2_TOKEN_LEAK2_BROWSER_HISTORY ATTACK</b> <br/></td></tr>
     <tr><td align="center">

A malicious client could attempt to obtain a token by fraud.
</td></tr>
   </table>>
   ];
    

    "4_4_2_2_TOKEN_LEAK2_BROWSER_HISTORY_countermeasure0" [ 
       fillcolor="#FFF2CC", style=filled, shape=polygon, color="#D6B656", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Validate Pre-Registered &quot;redirect_uri&quot;
 (5_2_3_5_VALIDATE_REDIRECT_URI) </b><br/><br/> 

An authorization server should require all clients to register their<br/>&quot;redirect_uri&quot;, and the &quot;redirect_uri&quot; should be the full<br/>URI as defined in [RFC6749].  The way that this registration is performed is out<br/>of scope of this document.  As per the core spec, every actual redirect URI sent<br/>with the respective[...]
 </td></tr>
   </table>>
   ]

    "4_4_2_2_TOKEN_LEAK2_BROWSER_HISTORY_countermeasure0" -> "4_4_2_2_TOKEN_LEAK2_BROWSER_HISTORY" [label = " mitigates"]

    "4_4_2_2_TOKEN_LEAK2_BROWSER_HISTORY_countermeasure1" [ 
       fillcolor="#FFF2CC", style=filled, shape=polygon, color="#D6B656", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Validation of Client Properties by End User
 (5_2_4_3_VALIDATION_OF_CLIENT_BY_END_USER) </b><br/><br/> 

In the authorization process, the user is typically asked to approve a clientâ€™s<br/>request for authorization. This is an important security mechanism by itself<br/>because the end user can be involved in the validation of client properties,<br/>such as whether the client name known to the authorization server fits the[...]
 </td></tr>
   </table>>
   ]

    "4_4_2_2_TOKEN_LEAK2_BROWSER_HISTORY_countermeasure1" -> "4_4_2_2_TOKEN_LEAK2_BROWSER_HISTORY" [label = " mitigates"]

    "4_4_2_2_TOKEN_LEAK2_BROWSER_HISTORY_countermeasure2" [ 
       fillcolor="#FFF2CC", style=filled, shape=polygon, color="#D6B656", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Automatic Processing of Repeated Authorizations Requires Client Validation
 (5_2_4_1_REPEAT_VALIDATE_CLIENT) </b><br/><br/> 

Authorization servers should NOT automatically process repeat authorizations<br/>where the client is not authenticated through a client secret or some other<br/>authentication mechanism such as a signed authentication assertion certificate<br/>(Section 5.2.3.7) or validation of a pre-registered redirect URI (Section<br/>5.[...]
 </td></tr>
   </table>>
   ]

    "4_4_2_2_TOKEN_LEAK2_BROWSER_HISTORY_countermeasure2" -> "4_4_2_2_TOKEN_LEAK2_BROWSER_HISTORY" [label = " mitigates"]

    "4_4_2_2_TOKEN_LEAK2_BROWSER_HISTORY_countermeasure3" [ 
       fillcolor="#FFF2CC", style=filled, shape=polygon, color="#D6B656", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Automatic Processing of Repeated Authorizations Requires Client Validation
 (REQUIRE_USER_MANUAL_STEP) </b><br/><br/> 

If the authorization server automatically authenticates the end user, it may<br/>nevertheless require some user input in order to prevent screen scraping.<br/>Examples are CAPTCHAs (Completely Automated Public Turing tests to tell<br/>Computers and Humans Apart) or other multi-factor authentication techniques such<br/>as r[...]
 </td></tr>
   </table>>
   ]

    "4_4_2_2_TOKEN_LEAK2_BROWSER_HISTORY_countermeasure3" -> "4_4_2_2_TOKEN_LEAK2_BROWSER_HISTORY" [label = " mitigates"]

    "4_4_2_2_TOKEN_LEAK2_BROWSER_HISTORY_countermeasure4" [ 
       fillcolor="#FFF2CC", style=filled, shape=polygon, color="#D6B656", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Limit Token Scope
 (5_1_5_1_LIMITED_SCOPE_TOKEN) </b><br/><br/> 

The authorization server may decide to reduce or limit the scope associated with<br/>a token. The basis of this decision is out of scope; examples are: &lt;br/&gt;o<br/>a client-specific policy, e.g., issue only less powerful tokens to public<br/>clients, &lt;br/&gt;o a service-specific policy, e.g., it is a very sensitive<br/>servic[...]
 </td></tr>
   </table>>
   ]

    "4_4_2_2_TOKEN_LEAK2_BROWSER_HISTORY_countermeasure4" -> "4_4_2_2_TOKEN_LEAK2_BROWSER_HISTORY" [label = " mitigates"]



               "4_4_2_2_TOKEN_LEAK2_BROWSER_HISTORY" -> "INTEGRITY" [label = " impacts"]
               "4_4_2_4_MANIPULATION_SCRIPTS" [ fillcolor="#F8CECC", style=filled, shape=polygon, color="#B85450"
    label= 
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="center"><b>4_4_2_4_MANIPULATION_SCRIPTS ATTACK</b> <br/></td></tr>
     <tr><td align="center">

A hostile party could act as the client web server and replace or modify the<br/>actual implementation of the client (script). This could be achieved using DNS<br/>or ARP spoofing. This applies to clients implemented within the web browser in a<br/>scripting language.
</td></tr>
   </table>>
   ];
    

    "4_4_2_4_MANIPULATION_SCRIPTS_countermeasure0" [ 
       fillcolor="#D5E8D4", style=filled, shape=polygon, color="#82B366", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

TLS for the authorization server
 (5_1_2_AUTH_SERVER_AUTHENTICATION) </b><br/><br/> 

Authorization servers should consider such attacks when developing services<br/>based on OAuth and should require the use of transport- layer security for any<br/>requests where the authenticity of the authorization server or of request<br/>responses is an issue (see Section 5.1.2). HTTPS server authentication or<br/>simi[...]
 </td></tr>
   </table>>
   ]

    "4_4_2_4_MANIPULATION_SCRIPTS_countermeasure0" -> "4_4_2_4_MANIPULATION_SCRIPTS" [label = " mitigates"]

    "4_4_2_4_MANIPULATION_SCRIPTS_countermeasure1" [ 
       fillcolor="#D5E8D4", style=filled, shape=polygon, color="#82B366", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Ensure Confidentiality of Requests (TLS)
 (5_1_1_CONFIDENTIAL_REQUESTS) </b><br/><br/> 

This is applicable to all requests sent from the client to the authorization<br/>server or resource server. While OAuth provides a mechanism for verifying the<br/>integrity of requests, it provides no guarantee of request confidentiality.<br/>Unless further precautions are taken, eavesdroppers will have full access to<br/>[...]
 </td></tr>
   </table>>
   ]

    "4_4_2_4_MANIPULATION_SCRIPTS_countermeasure1" -> "4_4_2_4_MANIPULATION_SCRIPTS" [label = " mitigates"]

    "4_4_2_4_MANIPULATION_SCRIPTS_countermeasure2" [ 
       fillcolor="#FFF2CC", style=filled, shape=polygon, color="#D6B656", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

One-time, per-use secrets (e.g., &quot;client_secret&quot;)
 (ONE_TIME_PER_USE_SECRET) </b><br/><br/> 

Introduce one-time, per-use secrets (e.g., &quot;client_secret&quot;) values<br/>that can only be used by scripts in a small time window once loaded from a<br/>server. The intention would be to reduce the effectiveness of copying client-<br/>side scripts for re-use in an attackerâ€™s modified code.
 </td></tr>
   </table>>
   ]

    "4_4_2_4_MANIPULATION_SCRIPTS_countermeasure2" -> "4_4_2_4_MANIPULATION_SCRIPTS" [label = " mitigates"]



               "4_4_2_4_MANIPULATION_SCRIPTS" -> "INTEGRITY" [label = " impacts"]
               "4_4_2_5_CSRF_IMPLICIT" [ fillcolor="#F8CECC", style=filled, shape=polygon, color="#B85450"
    label= 
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="center"><b>4_4_2_5_CSRF_IMPLICIT ATTACK</b> <br/></td></tr>
     <tr><td align="center">

CSRF attacks (see Section 4.4.1.8) also work against the redirect URI used in<br/>the implicit grant flow. An attacker could acquire an access token to their own<br/>protected resources. He could then construct a redirect URI and embed their<br/>access token in that URI. If he can trick the user into following the redi[...]
</td></tr>
   </table>>
   ];
    

    "4_4_2_5_CSRF_IMPLICIT_countermeasure0" [ 
       fillcolor="#FFF2CC", style=filled, shape=polygon, color="#D6B656", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Link the authorization request with the redirect URI (state param)
 (STATE_PARAM_VALIDATION) </b><br/><br/> 

The &quot;state&quot; parameter should be used to link the authorization request<br/>with the redirect URI used to deliver the access token. This will ensure that<br/>the client is not tricked into completing any redirect callback unless it is<br/>linked to an authorization request initiated by the client. The<br/>&quot;state&quot; parameter [...]
 </td></tr>
   </table>>
   ]

    "4_4_2_5_CSRF_IMPLICIT_countermeasure0" -> "4_4_2_5_CSRF_IMPLICIT" [label = " mitigates"]

    "4_4_2_5_CSRF_IMPLICIT_countermeasure1" [ 
       fillcolor="#FFF2CC", style=filled, shape=polygon, color="#D6B656", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Users can be educated to not follow untrusted URLs
 (USER_EDUCATION) </b><br/><br/> 

Client developers and end users can be educated to not follow untrusted URLs.
 </td></tr>
   </table>>
   ]

    "4_4_2_5_CSRF_IMPLICIT_countermeasure1" -> "4_4_2_5_CSRF_IMPLICIT" [label = " mitigates"]



               "4_4_2_5_CSRF_IMPLICIT" -> "INTEGRITY" [label = " impacts"]
               "4_4_2_6_TOKEN_SUBSTITUTION" [ fillcolor="#F8CECC", style=filled, shape=polygon, color="#B85450"
    label= 
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="center"><b>4_4_2_6_TOKEN_SUBSTITUTION ATTACK</b> <br/></td></tr>
     <tr><td align="center">

An attacker could attempt to log into an application or web site using a<br/>victimâ€™s identity. Applications relying on identity data provided by an OAuth<br/>protected service API to login users are vulnerable to this threat. This pattern<br/>can be found in so-called &quot;social login&quot; scenarios. As a prerequisite,<br/>a res[...]
</td></tr>
   </table>>
   ];
    

    "4_4_2_6_TOKEN_SUBSTITUTION_countermeasure0" [ 
       fillcolor="#FFF2CC", style=filled, shape=polygon, color="#D6B656", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Secure User Login Protocol
 (SECURE_USER_LOGIN_PROTOCOL) </b><br/><br/> 

Clients should use an appropriate protocol, such as OpenID (cf. [OPENID]) or<br/>SAML (cf. [OASIS.sstc-saml-bindings-1.1]) to implement user login. Both support<br/>audience restrictions on clients.
 </td></tr>
   </table>>
   ]

    "4_4_2_6_TOKEN_SUBSTITUTION_countermeasure0" -> "4_4_2_6_TOKEN_SUBSTITUTION" [label = " mitigates"]



               "4_4_2_6_TOKEN_SUBSTITUTION" -> "INTEGRITY" [label = " impacts"]





}

@enduml