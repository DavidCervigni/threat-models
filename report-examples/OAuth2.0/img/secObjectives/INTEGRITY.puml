







@startuml
digraph G {
rankdir="RL";
  node [shape=plaintext, fontname="Arial" fontsize="12"];
    
INTEGRITY [fillcolor="#bae9ff", style=filled shape=ellipse, color="#2bbcff", label="INTEGRITY", label= 
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="center"><b>INTEGRITY</b><br/>

Ability to maintain fundamental integrity of the system
</td></tr>
   </table>>]

               Client_Secrets_disclosure [ fillcolor="#F8CECC", style=filled, shape=polygon, color="#B85450"
    label= 
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="center"><b>Client_Secrets_disclosure ATTACK</b> <br/></td></tr>
     <tr><td align="center">

Obtain Secret From Source Code or Binary: This applies for all client types.<br/>For open source projects, secrets can be extracted directly from source code in<br/>their public repositories.  Secrets can be extracted from application binaries<br/>just as easily when the published source is not available to the attack[...]
</td></tr>
   </table>>
   ];
    

    Client_Secrets_disclosure_countermeasure0 [ 
       fillcolor="#D5E8D4", style=filled, shape=polygon, color="#82B366", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Checks on client's security policy
 (5.2.3.1_CLIENT_CHECK1) </b><br/><br/> 

Don't issue secrets to public clients or clients with inappropriate security<br/>policy
 </td></tr>
   </table>>
   ]

    Client_Secrets_disclosure_countermeasure0 -> Client_Secrets_disclosure [label = " mitigates"]

    Client_Secrets_disclosure_countermeasure1 [ 
       fillcolor="#D5E8D4", style=filled, shape=polygon, color="#82B366", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Require User Consent for Public Clients without Secret
 (5.2.3.2.User_Consent1) </b><br/><br/> 

Authorization servers should not allow automatic authorization for public<br/>clients.  The authorization server may issue an individual client id but should<br/>require that all authorizations are approved by the end user.  For clients<br/>without secrets, this is a countermeasure against the following threat:   -<br/>Im[...]
 </td></tr>
   </table>>
   ]

    Client_Secrets_disclosure_countermeasure1 -> Client_Secrets_disclosure [label = " mitigates"]

    Client_Secrets_disclosure_countermeasure2 [ 
       fillcolor="#D5E8D4", style=filled, shape=polygon, color="#82B366", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Issue a "client_id" Only in Combination with "redirect_uri"
 (5.2.3.3_client_id_to_redirect_uri) </b><br/><br/> 

The authorization server may issue a "client_id" and bind the   "client_id" to a<br/>certain pre-configured "redirect_uri".  Any   authorization request with another<br/>redirect URI is refused   automatically.  Alternatively, the authorization<br/>server should not   accept any dynamic redirect URI for such a "client_[...]
 </td></tr>
   </table>>
   ]

    Client_Secrets_disclosure_countermeasure2 -> Client_Secrets_disclosure [label = " mitigates"]

    Client_Secrets_disclosure_countermeasure3 [ 
       fillcolor="#D5E8D4", style=filled, shape=polygon, color="#82B366", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Issue Installation-Specific Client Secrets
 (5.2.3.4_SPECIFIC_CLIENT_SECRETS) </b><br/><br/> 

An authorization server may issue separate client identifiers and corresponding<br/>secrets to the different installations of a particular client (i.e., software<br/>package).  The effect of such an approach would be to turn otherwise "public"<br/>clients back into "confidential" clients. For web applications, this co[...]
 </td></tr>
   </table>>
   ]

    Client_Secrets_disclosure_countermeasure3 -> Client_Secrets_disclosure [label = " mitigates"]

    Client_Secrets_disclosure_countermeasure4 [ 
       fillcolor="#FFF2CC", style=filled, shape=polygon, color="#D6B656", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Validate Pre-Registered "redirect_uri"
 (5.2.3.5_VALIDATE_REDIRECT_URI) </b><br/><br/> 

An authorization server should require all clients to register their<br/>"redirect_uri", and the "redirect_uri" should be the full URI as defined in<br/>[RFC6749].  The way that this registration is performed is out of scope of this<br/>document.  As per the core spec, every actual redirect URI sent with the<br/>respective[...]
 </td></tr>
   </table>>
   ]

    Client_Secrets_disclosure_countermeasure4 -> Client_Secrets_disclosure [label = " mitigates"]



               Client_Secrets_disclosure -> INTEGRITY [label = " impacts"]
               4.3.1_EAVESDROPPING_ACCESS_TOKENS1 [ fillcolor="#F8CECC", style=filled, shape=polygon, color="#B85450"
    label= 
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="center"><b>4.3.1_EAVESDROPPING_ACCESS_TOKENS1 ATTACK</b> <br/></td></tr>
     <tr><td align="center">

Attackers may attempt to eavesdrop access tokens in transit from the<br/>authorization server to the client.
</td></tr>
   </table>>
   ];
    

    4.3.1_EAVESDROPPING_ACCESS_TOKENS1_countermeasure0 [ 
       fillcolor="#FFF2CC", style=filled, shape=polygon, color="#D6B656", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Secure transport layer to CLient to AUTH_SERVER by TLS
 (CLIENT_AUTH_SERVER_TLS) </b><br/><br/> 

As per the core OAuth spec, the authorization servers must ensure that these<br/>transmissions are protected using transport-layer mechanisms such as TLS (see<br/>Section 5.1.1).
 </td></tr>
   </table>>
   ]

    4.3.1_EAVESDROPPING_ACCESS_TOKENS1_countermeasure0 -> 4.3.1_EAVESDROPPING_ACCESS_TOKENS1 [label = " mitigates"]

    4.3.1_EAVESDROPPING_ACCESS_TOKENS1_countermeasure1 [ 
       fillcolor="#FFF2CC", style=filled, shape=polygon, color="#D6B656", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Limiting the scope of access tokens obtained through automated approvals
 (REDUCED_ACCESS_TOKEN_SCOPE) </b><br/><br/> 

Authorization servers can mitigate the risks associated with automatic<br/>processing by limiting the scope of access tokens obtained through automated<br/>approvals (Section 5.1.5.1).
 </td></tr>
   </table>>
   ]

    4.3.1_EAVESDROPPING_ACCESS_TOKENS1_countermeasure1 -> 4.3.1_EAVESDROPPING_ACCESS_TOKENS1 [label = " mitigates"]



               4.3.1_EAVESDROPPING_ACCESS_TOKENS1 -> INTEGRITY [label = " impacts"]
               4.3.2_AS_DB_TOKEN_DISCLOSURE [ fillcolor="#F8CECC", style=filled, shape=polygon, color="#B85450"
    label= 
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="center"><b>4.3.2_AS_DB_TOKEN_DISCLOSURE ATTACK</b> <br/></td></tr>
     <tr><td align="center">

An attacker may obtain access tokens from the authorization serverâ€™s database by<br/>gaining access to the database or launching a SQL injection attack.  This threat<br/>is applicable if the authorization server stores access tokens as handles in a<br/>database.
</td></tr>
   </table>>
   ];
    

    4.3.2_AS_DB_TOKEN_DISCLOSURE_countermeasure0 [ 
       fillcolor="#D5E8D4", style=filled, shape=polygon, color="#82B366", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Store access token hashes only (Section 5.1.4.1.3).
 (5.1.4.1.3_HASHED_TOKEN_DB) </b><br/><br/> 

Store access token hashes only (Section 5.1.4.1.3).
 </td></tr>
   </table>>
   ]

    4.3.2_AS_DB_TOKEN_DISCLOSURE_countermeasure0 -> 4.3.2_AS_DB_TOKEN_DISCLOSURE [label = " mitigates"]

    4.3.2_AS_DB_TOKEN_DISCLOSURE_countermeasure1 [ 
       fillcolor="#FFF2CC", style=filled, shape=polygon, color="#D6B656", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Enforce Standard System Security Means
 (5.1.4.1.1_SYS_SEC) </b><br/><br/> 

A server system may be locked down so that no attacker may get access to<br/>sensitive configuration files and databases.
 </td></tr>
   </table>>
   ]

    4.3.2_AS_DB_TOKEN_DISCLOSURE_countermeasure1 -> 4.3.2_AS_DB_TOKEN_DISCLOSURE [label = " mitigates"]

    4.3.2_AS_DB_TOKEN_DISCLOSURE_countermeasure2 [ 
       fillcolor="#FFF2CC", style=filled, shape=polygon, color="#D6B656", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Enforce Standard SQL Injection Countermeasures
 (5.1.4.1.2_SQL_SEC) </b><br/><br/> 

If a client identifier or other authentication component is queried or compared<br/>against a SQL database, it may become possible for an injection attack to occur<br/>if parameters received are not validated before submission to the database.<br/><br/>o Ensure that server code is using the minimum database privileges [...]
 </td></tr>
   </table>>
   ]

    4.3.2_AS_DB_TOKEN_DISCLOSURE_countermeasure2 -> 4.3.2_AS_DB_TOKEN_DISCLOSURE [label = " mitigates"]



               4.3.2_AS_DB_TOKEN_DISCLOSURE -> INTEGRITY [label = " impacts"]
               4.3.3_CLIENT_CREDENTIALS_DISCLOSURE [ fillcolor="#F8CECC", style=filled, shape=polygon, color="#B85450"
    label= 
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="center"><b>4.3.3_CLIENT_CREDENTIALS_DISCLOSURE ATTACK</b> <br/></td></tr>
     <tr><td align="center">

An attacker could attempt to eavesdrop the transmission of client credentials<br/>between the client and server during the client authentication process or during<br/>OAuth token requests.
</td></tr>
   </table>>
   ];
    

    4.3.3_CLIENT_CREDENTIALS_DISCLOSURE_countermeasure0 [ 
       fillcolor="#D5E8D4", style=filled, shape=polygon, color="#82B366", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Ensure Confidentiality of Requests (TLS)
 (5.1.1_CONFIDENTIAL_REQUESTS) </b><br/><br/> 

This is applicable to all requests sent from the client to the authorization<br/>server or resource server. While OAuth provides a mechanism for verifying the<br/>integrity of requests, it provides no guarantee of request confidentiality.<br/>Unless further precautions are taken, eavesdroppers will have full access to<br/>[...]
 </td></tr>
   </table>>
   ]

    4.3.3_CLIENT_CREDENTIALS_DISCLOSURE_countermeasure0 -> 4.3.3_CLIENT_CREDENTIALS_DISCLOSURE [label = " mitigates"]

    4.3.3_CLIENT_CREDENTIALS_DISCLOSURE_countermeasure1 [ 
       fillcolor="#FFF2CC", style=filled, shape=polygon, color="#D6B656", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Do not send plaintext credentials
 (CONFIDENTIAL_CREDENTIALS_REQUESTS) </b><br/><br/> 

Use alternative authentication means that do not require the sending of<br/>plaintext credentials over the wire (e.g., Hash-based Message Authentication<br/>Code).
 </td></tr>
   </table>>
   ]

    4.3.3_CLIENT_CREDENTIALS_DISCLOSURE_countermeasure1 -> 4.3.3_CLIENT_CREDENTIALS_DISCLOSURE [label = " mitigates"]



               4.3.3_CLIENT_CREDENTIALS_DISCLOSURE -> INTEGRITY [label = " impacts"]
               4.3.4_CLIENT_CREDENTIALS_DISCLOSURE [ fillcolor="#F8CECC", style=filled, shape=polygon, color="#B85450"
    label= 
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="center"><b>4.3.4_CLIENT_CREDENTIALS_DISCLOSURE ATTACK</b> <br/></td></tr>
     <tr><td align="center">

An attacker may obtain valid "client_id"/secret combinations from the<br/>authorization serverâ€™s database by gaining access to the database or launching a<br/>SQL injection attack.
</td></tr>
   </table>>
   ];
    

    4.3.4_CLIENT_CREDENTIALS_DISCLOSURE_countermeasure0 [ 
       fillcolor="#FFF2CC", style=filled, shape=polygon, color="#D6B656", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Enforce Standard SQL Injection Countermeasures
 (5.1.4.1.2_SQL_SEC) </b><br/><br/> 

If a client identifier or other authentication component is queried or compared<br/>against a SQL database, it may become possible for an injection attack to occur<br/>if parameters received are not validated before submission to the database.<br/><br/>o Ensure that server code is using the minimum database privileges [...]
 </td></tr>
   </table>>
   ]

    4.3.4_CLIENT_CREDENTIALS_DISCLOSURE_countermeasure0 -> 4.3.4_CLIENT_CREDENTIALS_DISCLOSURE [label = " mitigates"]

    4.3.4_CLIENT_CREDENTIALS_DISCLOSURE_countermeasure1 [ 
       fillcolor="#FFF2CC", style=filled, shape=polygon, color="#D6B656", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Enforce Standard System Security Means
 (5.1.4.1.1_SYS_SEC) </b><br/><br/> 

A server system may be locked down so that no attacker may get access to<br/>sensitive configuration files and databases.
 </td></tr>
   </table>>
   ]

    4.3.4_CLIENT_CREDENTIALS_DISCLOSURE_countermeasure1 -> 4.3.4_CLIENT_CREDENTIALS_DISCLOSURE [label = " mitigates"]

    4.3.4_CLIENT_CREDENTIALS_DISCLOSURE_countermeasure2 [ 
       fillcolor="#FFF2CC", style=filled, shape=polygon, color="#D6B656", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Enforce Credential Storage Protection Best Practices
 (5.1.4.1_CRED_PROTECTION) </b><br/><br/> 

Administrators should undertake industry best practices to protect the storage<br/>of credentials (for example, see [OWASP]). Such practices may include but are<br/>not limited to the following sub-sections.
 </td></tr>
   </table>>
   ]

    4.3.4_CLIENT_CREDENTIALS_DISCLOSURE_countermeasure2 -> 4.3.4_CLIENT_CREDENTIALS_DISCLOSURE [label = " mitigates"]



               4.3.4_CLIENT_CREDENTIALS_DISCLOSURE -> INTEGRITY [label = " impacts"]
               4.3.5_CLIENT_SECRET_BRUTE_FORCE [ fillcolor="#F8CECC", style=filled, shape=polygon, color="#B85450"
    label= 
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="center"><b>4.3.5_CLIENT_SECRET_BRUTE_FORCE ATTACK</b> <br/></td></tr>
     <tr><td align="center">

An attacker may try to guess valid "client_id"/secret pairs.
</td></tr>
   </table>>
   ];
    

    4.3.5_CLIENT_SECRET_BRUTE_FORCE_countermeasure0 [ 
       fillcolor="#FFF2CC", style=filled, shape=polygon, color="#D6B656", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Use High Entropy for Secrets
 (5.1.4.2.2_HIGH_ENTROPY_SECRETS) </b><br/><br/> 

When creating secrets not intended for usage by human users (e.g., client<br/>secrets or token handles), the authorization server should include a reasonable<br/>level of entropy in order to mitigate the risk of guessing attacks. The token<br/>value should be >=128 bits long and constructed from a cryptographically<br/>str[...]
 </td></tr>
   </table>>
   ]

    4.3.5_CLIENT_SECRET_BRUTE_FORCE_countermeasure0 -> 4.3.5_CLIENT_SECRET_BRUTE_FORCE [label = " mitigates"]

    4.3.5_CLIENT_SECRET_BRUTE_FORCE_countermeasure1 [ 
       fillcolor="#FFF2CC", style=filled, shape=polygon, color="#D6B656", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Lock Accounts
 (5.1.4.2.3_LOCK_ACCOUNTS) </b><br/><br/> 

Online attacks on passwords can be mitigated by locking the respective accounts<br/>after a certain number of failed attempts. Note: This measure can be abused to<br/>lock down legitimate service users.
 </td></tr>
   </table>>
   ]

    4.3.5_CLIENT_SECRET_BRUTE_FORCE_countermeasure1 -> 4.3.5_CLIENT_SECRET_BRUTE_FORCE [label = " mitigates"]

    4.3.5_CLIENT_SECRET_BRUTE_FORCE_countermeasure2 [ 
       fillcolor="#FFF2CC", style=filled, shape=polygon, color="#D6B656", label =     
    <<table border="0" cellborder="0" cellspacing="0">
     <tr><td align="left"><b> 

Use strong client authentication
 (5.2.3.7_STRONG_CLIENT_AUTHENTICATION) </b><br/><br/> 

By using an alternative form of authentication such as client assertion [OAuth-<br/>ASSERTIONS], the need to distribute a "client_secret" is eliminated. This may<br/>require the use of a secure private key store or other supplemental<br/>authentication system as specified by the client assertion issuer in its<br/>authentica[...]
 </td></tr>
   </table>>
   ]

    4.3.5_CLIENT_SECRET_BRUTE_FORCE_countermeasure2 -> 4.3.5_CLIENT_SECRET_BRUTE_FORCE [label = " mitigates"]



               4.3.5_CLIENT_SECRET_BRUTE_FORCE -> INTEGRITY [label = " impacts"]





}

@enduml